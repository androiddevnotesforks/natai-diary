/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApiContext, ApiContext } from "./apiContext";
import type * as Fetcher from "./apiFetcher";
import { apiFetch } from "./apiFetcher";
import type * as Schemas from "./apiSchemas";

export type PostFeedbackError = Fetcher.ErrorWrapper<undefined>;

export type PostFeedbackVariables = {
  body: Schemas.FeedbackRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostFeedback = (
  variables: PostFeedbackVariables,
  signal?: AbortSignal
) =>
  apiFetch<undefined, PostFeedbackError, Schemas.FeedbackRequest, {}, {}, {}>({
    url: "/api/v1/feedback",
    method: "post",
    ...variables,
    signal,
  });

export const usePostFeedback = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostFeedbackError,
      PostFeedbackVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PostFeedbackError,
    PostFeedbackVariables
  >(
    (variables: PostFeedbackVariables) =>
      fetchPostFeedback({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetStaticError = Fetcher.ErrorWrapper<undefined>;

export type GetStaticVariables = ApiContext["fetcherOptions"];

export const fetchGetStatic = (
  variables: GetStaticVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.StaticContentResponse,
    GetStaticError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/static", method: "get", ...variables, signal });

export const useGetStatic = <TData = Schemas.StaticContentResponse>(
  variables: GetStaticVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.StaticContentResponse,
      GetStaticError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.StaticContentResponse,
    GetStaticError,
    TData
  >(
    queryKeyFn({ path: "/api/v1/static", operationId: "getStatic", variables }),
    ({ signal }) => fetchGetStatic({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostAttachmentsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.AuthRequiredErrorResponse;
}>;

export type PostAttachmentsVariables = {
  body: Schemas.UploadAttachmentRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostAttachments = (
  variables: PostAttachmentsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.SignedUploadUrl,
    PostAttachmentsError,
    Schemas.UploadAttachmentRequest,
    {},
    {},
    {}
  >({ url: "/api/v1/attachments", method: "post", ...variables, signal });

export const usePostAttachments = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SignedUploadUrl,
      PostAttachmentsError,
      PostAttachmentsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.SignedUploadUrl,
    PostAttachmentsError,
    PostAttachmentsVariables
  >(
    (variables: PostAttachmentsVariables) =>
      fetchPostAttachments({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostChangeEmailError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 422;
      payload: Schemas.ChangeEmailErrorRef;
    }
  | {
      status: 500;
      payload: Schemas.ServerErrorRef;
    }
>;

export type PostChangeEmailVariables = {
  body: Schemas.ChangeEmailRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostChangeEmail = (
  variables: PostChangeEmailVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PostChangeEmailError,
    Schemas.ChangeEmailRequest,
    {},
    {},
    {}
  >({ url: "/api/v1/change-email", method: "post", ...variables, signal });

export const usePostChangeEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostChangeEmailError,
      PostChangeEmailVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PostChangeEmailError,
    PostChangeEmailVariables
  >(
    (variables: PostChangeEmailVariables) =>
      fetchPostChangeEmail({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostChangeEmailConfirmationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 404;
      payload: Schemas.ChangeEmailConfirmationErrorRef;
    }
  | {
      status: 422;
      payload: Schemas.ChangeEmailConfirmationErrorRef;
    }
  | {
      status: 500;
      payload: Schemas.ServerErrorRef;
    }
>;

export type PostChangeEmailConfirmationVariables = {
  body: Schemas.ChangeEmailConfirmationRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostChangeEmailConfirmation = (
  variables: PostChangeEmailConfirmationVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PostChangeEmailConfirmationError,
    Schemas.ChangeEmailConfirmationRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1/change-email-confirmation",
    method: "post",
    ...variables,
    signal,
  });

export const usePostChangeEmailConfirmation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostChangeEmailConfirmationError,
      PostChangeEmailConfirmationVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PostChangeEmailConfirmationError,
    PostChangeEmailConfirmationVariables
  >(
    (variables: PostChangeEmailConfirmationVariables) =>
      fetchPostChangeEmailConfirmation({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostChangePasswordError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 422;
      payload: Schemas.ChangePasswordErrorRef;
    }
  | {
      status: 500;
      payload: Schemas.ServerErrorRef;
    }
>;

export type PostChangePasswordVariables = {
  body: Schemas.ChangePasswordRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostChangePassword = (
  variables: PostChangePasswordVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PostChangePasswordError,
    Schemas.ChangePasswordRequest,
    {},
    {},
    {}
  >({ url: "/api/v1/change-password", method: "post", ...variables, signal });

export const usePostChangePassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostChangePasswordError,
      PostChangePasswordVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PostChangePasswordError,
    PostChangePasswordVariables
  >(
    (variables: PostChangePasswordVariables) =>
      fetchPostChangePassword({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetMeError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.AuthRequiredErrorResponse;
}>;

export type GetMeVariables = ApiContext["fetcherOptions"];

export const fetchGetMe = (variables: GetMeVariables, signal?: AbortSignal) =>
  apiFetch<Schemas.UserInfoResponse, GetMeError, undefined, {}, {}, {}>({
    url: "/api/v1/me",
    method: "get",
    ...variables,
    signal,
  });

export const useGetMe = <TData = Schemas.UserInfoResponse>(
  variables: GetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserInfoResponse, GetMeError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.UserInfoResponse, GetMeError, TData>(
    queryKeyFn({ path: "/api/v1/me", operationId: "getMe", variables }),
    ({ signal }) => fetchGetMe({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type DeleteMeError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.ServerErrorRef;
}>;

export type DeleteMeVariables = ApiContext["fetcherOptions"];

export const fetchDeleteMe = (
  variables: DeleteMeVariables,
  signal?: AbortSignal
) =>
  apiFetch<undefined, DeleteMeError, undefined, {}, {}, {}>({
    url: "/api/v1/me",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteMe = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, DeleteMeError, DeleteMeVariables>,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<undefined, DeleteMeError, DeleteMeVariables>(
    (variables: DeleteMeVariables) =>
      fetchDeleteMe({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostLoginError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.LoginErrorRef;
    }
  | {
      status: 500;
      payload: Schemas.ServerErrorRef;
    }
>;

export type PostLoginVariables = {
  body: Schemas.LoginRequestRef;
} & ApiContext["fetcherOptions"];

export const fetchPostLogin = (
  variables: PostLoginVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.LoginSuccessResponse,
    PostLoginError,
    Schemas.LoginRequestRef,
    {},
    {},
    {}
  >({ url: "/api/v1/login", method: "post", ...variables, signal });

export const usePostLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LoginSuccessResponse,
      PostLoginError,
      PostLoginVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.LoginSuccessResponse,
    PostLoginError,
    PostLoginVariables
  >(
    (variables: PostLoginVariables) =>
      fetchPostLogin({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetLogoutError = Fetcher.ErrorWrapper<undefined>;

export type GetLogoutVariables = ApiContext["fetcherOptions"];

export const fetchGetLogout = (
  variables: GetLogoutVariables,
  signal?: AbortSignal
) =>
  apiFetch<undefined, GetLogoutError, undefined, {}, {}, {}>({
    url: "/api/v1/logout",
    method: "get",
    ...variables,
    signal,
  });

export const useGetLogout = <TData = undefined>(
  variables: GetLogoutVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetLogoutError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<undefined, GetLogoutError, TData>(
    queryKeyFn({ path: "/api/v1/logout", operationId: "getLogout", variables }),
    ({ signal }) => fetchGetLogout({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostPasswordResetError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 404;
      payload: Schemas.ResetPasswordErrorRef;
    }
  | {
      status: 500;
      payload: Schemas.ServerErrorRef;
    }
>;

export type PostPasswordResetVariables = {
  body: Schemas.PasswordResetRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostPasswordReset = (
  variables: PostPasswordResetVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PostPasswordResetError,
    Schemas.PasswordResetRequest,
    {},
    {},
    {}
  >({ url: "/api/v1/password-reset", method: "post", ...variables, signal });

export const usePostPasswordReset = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostPasswordResetError,
      PostPasswordResetVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PostPasswordResetError,
    PostPasswordResetVariables
  >(
    (variables: PostPasswordResetVariables) =>
      fetchPostPasswordReset({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostPasswordResetConfirmationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 404;
      payload: Schemas.ResetPasswordConfirmationErrorRef;
    }
  | {
      status: 422;
      payload: Schemas.ResetPasswordConfirmationErrorRef;
    }
  | {
      status: 500;
      payload: Schemas.ServerErrorRef;
    }
>;

export type PostPasswordResetConfirmationVariables = {
  body: Schemas.PasswordResetConfirmationRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostPasswordResetConfirmation = (
  variables: PostPasswordResetConfirmationVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PostPasswordResetConfirmationError,
    Schemas.PasswordResetConfirmationRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1/password-reset-confirmation",
    method: "post",
    ...variables,
    signal,
  });

export const usePostPasswordResetConfirmation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostPasswordResetConfirmationError,
      PostPasswordResetConfirmationVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PostPasswordResetConfirmationError,
    PostPasswordResetConfirmationVariables
  >(
    (variables: PostPasswordResetConfirmationVariables) =>
      fetchPostPasswordResetConfirmation({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostRegistrationError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 422;
      payload: Schemas.RegistrationErrorResponseRef;
    }
  | {
      status: 500;
      payload: Schemas.ServerErrorRef;
    }
>;

export type PostRegistrationVariables = {
  body: Schemas.RegistrationRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostRegistration = (
  variables: PostRegistrationVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.RegistrationSuccessResponse,
    PostRegistrationError,
    Schemas.RegistrationRequest,
    {},
    {},
    {}
  >({ url: "/api/v1/registration", method: "post", ...variables, signal });

export const usePostRegistration = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RegistrationSuccessResponse,
      PostRegistrationError,
      PostRegistrationVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.RegistrationSuccessResponse,
    PostRegistrationError,
    PostRegistrationVariables
  >(
    (variables: PostRegistrationVariables) =>
      fetchPostRegistration({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostVerifyEmailError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 404;
      payload: Schemas.VerifyEmailResponseRef;
    }
  | {
      status: 422;
      payload: Schemas.VerifyEmailResponseRef;
    }
  | {
      status: 500;
      payload: Schemas.ServerErrorRef;
    }
>;

export type PostVerifyEmailVariables = {
  body: Schemas.VerifyEmailRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostVerifyEmail = (
  variables: PostVerifyEmailVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PostVerifyEmailError,
    Schemas.VerifyEmailRequest,
    {},
    {},
    {}
  >({ url: "/api/v1/verify-email", method: "post", ...variables, signal });

export const usePostVerifyEmail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostVerifyEmailError,
      PostVerifyEmailVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PostVerifyEmailError,
    PostVerifyEmailVariables
  >(
    (variables: PostVerifyEmailVariables) =>
      fetchPostVerifyEmail({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostLinksBuyError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 422;
      payload: Schemas.BuySuggestionLinksErrorRef;
    }
>;

export type PostLinksBuyVariables = ApiContext["fetcherOptions"];

export const fetchPostLinksBuy = (
  variables: PostLinksBuyVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.BuyFeatureResponse,
    PostLinksBuyError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/links/buy", method: "post", ...variables, signal });

export const usePostLinksBuy = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BuyFeatureResponse,
      PostLinksBuyError,
      PostLinksBuyVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.BuyFeatureResponse,
    PostLinksBuyError,
    PostLinksBuyVariables
  >(
    (variables: PostLinksBuyVariables) =>
      fetchPostLinksBuy({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PutNotesByIdPathParams = {
  id: string;
};

export type PutNotesByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 403;
      payload: Schemas.AccessDeniedErrorRef;
    }
  | {
      status: 404;
      payload: Schemas.NotFoundErrorRef;
    }
>;

export type PutNotesByIdVariables = {
  body: Schemas.UpdateNoteRequestV1;
  pathParams: PutNotesByIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutNotesById = (
  variables: PutNotesByIdVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PutNotesByIdError,
    Schemas.UpdateNoteRequestV1,
    {},
    {},
    PutNotesByIdPathParams
  >({ url: "/api/v1/notes/{id}", method: "put", ...variables, signal });

export const usePutNotesById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PutNotesByIdError,
      PutNotesByIdVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PutNotesByIdError,
    PutNotesByIdVariables
  >(
    (variables: PutNotesByIdVariables) =>
      fetchPutNotesById({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteNotesByIdPathParams = {
  id: string;
};

export type DeleteNotesByIdError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 403;
      payload: Schemas.AccessDeniedErrorRef;
    }
  | {
      status: 404;
      payload: Schemas.NotFoundErrorRef;
    }
>;

export type DeleteNotesByIdVariables = {
  pathParams: DeleteNotesByIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteNotesById = (
  variables: DeleteNotesByIdVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    DeleteNotesByIdError,
    undefined,
    {},
    {},
    DeleteNotesByIdPathParams
  >({ url: "/api/v1/notes/{id}", method: "delete", ...variables, signal });

export const useDeleteNotesById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteNotesByIdError,
      DeleteNotesByIdVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    DeleteNotesByIdError,
    DeleteNotesByIdVariables
  >(
    (variables: DeleteNotesByIdVariables) =>
      fetchDeleteNotesById({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetCategoriesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.AuthRequiredErrorResponse;
}>;

export type GetCategoriesVariables = ApiContext["fetcherOptions"];

export const fetchGetCategories = (
  variables: GetCategoriesVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.FindAllLinkCategoriesResponse,
    GetCategoriesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/categories", method: "get", ...variables, signal });

export const useGetCategories = <TData = Schemas.FindAllLinkCategoriesResponse>(
  variables: GetCategoriesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FindAllLinkCategoriesResponse,
      GetCategoriesError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.FindAllLinkCategoriesResponse,
    GetCategoriesError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/categories",
      operationId: "getCategories",
      variables,
    }),
    ({ signal }) =>
      fetchGetCategories({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetNotesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.AuthRequiredErrorResponse;
}>;

export type GetNotesVariables = ApiContext["fetcherOptions"];

export const fetchGetNotes = (
  variables: GetNotesVariables,
  signal?: AbortSignal
) =>
  apiFetch<Schemas.FindAllNotesResponse, GetNotesError, undefined, {}, {}, {}>({
    url: "/api/v1/notes",
    method: "get",
    ...variables,
    signal,
  });

export const useGetNotes = <TData = Schemas.FindAllNotesResponse>(
  variables: GetNotesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FindAllNotesResponse,
      GetNotesError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.FindAllNotesResponse,
    GetNotesError,
    TData
  >(
    queryKeyFn({ path: "/api/v1/notes", operationId: "getNotes", variables }),
    ({ signal }) => fetchGetNotes({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostNotesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
>;

export type PostNotesVariables = {
  body: Schemas.NewNoteRequestV1;
} & ApiContext["fetcherOptions"];

export const fetchPostNotes = (
  variables: PostNotesVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.NewNoteResponse,
    PostNotesError,
    Schemas.NewNoteRequestV1,
    {},
    {},
    {}
  >({ url: "/api/v1/notes", method: "post", ...variables, signal });

export const usePostNotes = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.NewNoteResponse,
      PostNotesError,
      PostNotesVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.NewNoteResponse,
    PostNotesError,
    PostNotesVariables
  >(
    (variables: PostNotesVariables) =>
      fetchPostNotes({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetSuggestionsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.AuthRequiredErrorResponse;
}>;

export type GetSuggestionsVariables = ApiContext["fetcherOptions"];

export const fetchGetSuggestions = (
  variables: GetSuggestionsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.FindAllSuggestionsResponse,
    GetSuggestionsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/suggestions", method: "get", ...variables, signal });

export const useGetSuggestions = <TData = Schemas.FindAllSuggestionsResponse>(
  variables: GetSuggestionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FindAllSuggestionsResponse,
      GetSuggestionsError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.FindAllSuggestionsResponse,
    GetSuggestionsError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/suggestions",
      operationId: "getSuggestions",
      variables,
    }),
    ({ signal }) =>
      fetchGetSuggestions({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetLinksExampleError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.NotFoundErrorRef;
}>;

export type GetLinksExampleVariables = ApiContext["fetcherOptions"];

export const fetchGetLinksExample = (
  variables: GetLinksExampleVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.SuggestionLinksResponse,
    GetLinksExampleError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/links-example", method: "get", ...variables, signal });

export const useGetLinksExample = <TData = Schemas.SuggestionLinksResponse>(
  variables: GetLinksExampleVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SuggestionLinksResponse,
      GetLinksExampleError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SuggestionLinksResponse,
    GetLinksExampleError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/links-example",
      operationId: "getLinksExample",
      variables,
    }),
    ({ signal }) =>
      fetchGetLinksExample({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetNotesByIdAttachmentsPathParams = {
  id: string;
};

export type GetNotesByIdAttachmentsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.GetNoteAttachmentsErrorRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 404;
      payload: Schemas.NotFoundErrorRef;
    }
  | {
      status: 422;
      payload: Schemas.GetNoteAttachmentsErrorRef;
    }
>;

export type GetNotesByIdAttachmentsVariables = {
  pathParams: GetNotesByIdAttachmentsPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetNotesByIdAttachments = (
  variables: GetNotesByIdAttachmentsVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.NoteAttachmentsResponse,
    GetNotesByIdAttachmentsError,
    undefined,
    {},
    {},
    GetNotesByIdAttachmentsPathParams
  >({
    url: "/api/v1/notes/{id}/attachments",
    method: "get",
    ...variables,
    signal,
  });

export const useGetNotesByIdAttachments = <
  TData = Schemas.NoteAttachmentsResponse
>(
  variables: GetNotesByIdAttachmentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.NoteAttachmentsResponse,
      GetNotesByIdAttachmentsError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.NoteAttachmentsResponse,
    GetNotesByIdAttachmentsError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/notes/{id}/attachments",
      operationId: "getNotesByIdAttachments",
      variables,
    }),
    ({ signal }) =>
      fetchGetNotesByIdAttachments({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetSuggestionByIdLinksPathParams = {
  id: string;
};

export type GetSuggestionByIdLinksError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 404;
      payload: Schemas.NotFoundErrorRef;
    }
  | {
      status: 422;
      payload: Schemas.GetSuggestionLinksErrorRef;
    }
>;

export type GetSuggestionByIdLinksVariables = {
  pathParams: GetSuggestionByIdLinksPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetSuggestionByIdLinks = (
  variables: GetSuggestionByIdLinksVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.SuggestionLinksResponse,
    GetSuggestionByIdLinksError,
    undefined,
    {},
    {},
    GetSuggestionByIdLinksPathParams
  >({
    url: "/api/v1/suggestion/{id}/links",
    method: "get",
    ...variables,
    signal,
  });

export const useGetSuggestionByIdLinks = <
  TData = Schemas.SuggestionLinksResponse
>(
  variables: GetSuggestionByIdLinksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SuggestionLinksResponse,
      GetSuggestionByIdLinksError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.SuggestionLinksResponse,
    GetSuggestionByIdLinksError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/suggestion/{id}/links",
      operationId: "getSuggestionByIdLinks",
      variables,
    }),
    ({ signal }) =>
      fetchGetSuggestionByIdLinks({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostLinksLoadError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
>;

export type PostLinksLoadVariables = {
  body: Schemas.LoadLinkRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostLinksLoad = (
  variables: PostLinksLoadVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.LoadLinkResponse,
    PostLinksLoadError,
    Schemas.LoadLinkRequest,
    {},
    {},
    {}
  >({ url: "/api/v1/links/load", method: "post", ...variables, signal });

export const usePostLinksLoad = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LoadLinkResponse,
      PostLinksLoadError,
      PostLinksLoadVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.LoadLinkResponse,
    PostLinksLoadError,
    PostLinksLoadVariables
  >(
    (variables: PostLinksLoadVariables) =>
      fetchPostLinksLoad({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostLinksError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
>;

export type PostLinksVariables = {
  body: Schemas.NewLinkRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostLinks = (
  variables: PostLinksVariables,
  signal?: AbortSignal
) =>
  apiFetch<undefined, PostLinksError, Schemas.NewLinkRequest, {}, {}, {}>({
    url: "/api/v1/links",
    method: "post",
    ...variables,
    signal,
  });

export const usePostLinks = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostLinksError,
      PostLinksVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<undefined, PostLinksError, PostLinksVariables>(
    (variables: PostLinksVariables) =>
      fetchPostLinks({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostNotesV2Error = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
>;

export type PostNotesV2Variables = {
  body: Schemas.NewNoteRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostNotesV2 = (
  variables: PostNotesV2Variables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.NewNoteResponse,
    PostNotesV2Error,
    Schemas.NewNoteRequest,
    {},
    {},
    {}
  >({ url: "/api/v2/notes", method: "post", ...variables, signal });

export const usePostNotesV2 = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.NewNoteResponse,
      PostNotesV2Error,
      PostNotesV2Variables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.NewNoteResponse,
    PostNotesV2Error,
    PostNotesV2Variables
  >(
    (variables: PostNotesV2Variables) =>
      fetchPostNotesV2({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PutSuggestionsByIdFeedbackPathParams = {
  id: string;
};

export type PutSuggestionsByIdFeedbackError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 404;
      payload: Schemas.NotFoundErrorRef;
    }
>;

export type PutSuggestionsByIdFeedbackVariables = {
  body: Schemas.SuggestionFeedbackRequest;
  pathParams: PutSuggestionsByIdFeedbackPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutSuggestionsByIdFeedback = (
  variables: PutSuggestionsByIdFeedbackVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PutSuggestionsByIdFeedbackError,
    Schemas.SuggestionFeedbackRequest,
    {},
    {},
    PutSuggestionsByIdFeedbackPathParams
  >({
    url: "/api/v1/suggestions/{id}/feedback",
    method: "put",
    ...variables,
    signal,
  });

export const usePutSuggestionsByIdFeedback = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PutSuggestionsByIdFeedbackError,
      PutSuggestionsByIdFeedbackVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PutSuggestionsByIdFeedbackError,
    PutSuggestionsByIdFeedbackVariables
  >(
    (variables: PutSuggestionsByIdFeedbackVariables) =>
      fetchPutSuggestionsByIdFeedback({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetSyncQueryParams = {
  /**
   * Only return notes updated since this date
   *
   * @format date-time
   */
  updatedSince?: string;
};

export type GetSyncError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
>;

export type GetSyncVariables = {
  queryParams?: GetSyncQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetSync = (
  variables: GetSyncVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.FindAllNotesResponse,
    GetSyncError,
    undefined,
    {},
    GetSyncQueryParams,
    {}
  >({ url: "/api/v1/sync", method: "get", ...variables, signal });

export const useGetSync = <TData = Schemas.FindAllNotesResponse>(
  variables: GetSyncVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FindAllNotesResponse,
      GetSyncError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.FindAllNotesResponse, GetSyncError, TData>(
    queryKeyFn({ path: "/api/v1/sync", operationId: "getSync", variables }),
    ({ signal }) => fetchGetSync({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PutNotesByIdV2PathParams = {
  id: string;
};

export type PutNotesByIdV2Error = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 403;
      payload: Schemas.AccessDeniedErrorRef;
    }
  | {
      status: 404;
      payload: Schemas.NotFoundErrorRef;
    }
>;

export type PutNotesByIdV2Variables = {
  body: Schemas.UpdateNoteRequest;
  pathParams: PutNotesByIdV2PathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutNotesByIdV2 = (
  variables: PutNotesByIdV2Variables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PutNotesByIdV2Error,
    Schemas.UpdateNoteRequest,
    {},
    {},
    PutNotesByIdV2PathParams
  >({ url: "/api/v2/notes/{id}", method: "put", ...variables, signal });

export const usePutNotesByIdV2 = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PutNotesByIdV2Error,
      PutNotesByIdV2Variables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PutNotesByIdV2Error,
    PutNotesByIdV2Variables
  >(
    (variables: PutNotesByIdV2Variables) =>
      fetchPutNotesByIdV2({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostLinksUploadImageError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
>;

export type PostLinksUploadImageVariables = {
  body: Schemas.UploadLinkImageRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostLinksUploadImage = (
  variables: PostLinksUploadImageVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.UploadLinkImageResponse,
    PostLinksUploadImageError,
    Schemas.UploadLinkImageRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1/links/upload-image",
    method: "post",
    ...variables,
    signal,
  });

export const usePostLinksUploadImage = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UploadLinkImageResponse,
      PostLinksUploadImageError,
      PostLinksUploadImageVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.UploadLinkImageResponse,
    PostLinksUploadImageError,
    PostLinksUploadImageVariables
  >(
    (variables: PostLinksUploadImageVariables) =>
      fetchPostLinksUploadImage({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetArticlesError = Fetcher.ErrorWrapper<undefined>;

export type GetArticlesVariables = ApiContext["fetcherOptions"];

export const fetchGetArticles = (
  variables: GetArticlesVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.FindAllArticlesResponse,
    GetArticlesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/articles", method: "get", ...variables, signal });

export const useGetArticles = <TData = Schemas.FindAllArticlesResponse>(
  variables: GetArticlesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FindAllArticlesResponse,
      GetArticlesError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.FindAllArticlesResponse,
    GetArticlesError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/articles",
      operationId: "getArticles",
      variables,
    }),
    ({ signal }) =>
      fetchGetArticles({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostArticlesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
>;

export type PostArticlesVariables = {
  body: Schemas.NewArticleRequest;
} & ApiContext["fetcherOptions"];

export const fetchPostArticles = (
  variables: PostArticlesVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.NewArticleResponse,
    PostArticlesError,
    Schemas.NewArticleRequest,
    {},
    {},
    {}
  >({ url: "/api/v1/articles", method: "post", ...variables, signal });

export const usePostArticles = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.NewArticleResponse,
      PostArticlesError,
      PostArticlesVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    Schemas.NewArticleResponse,
    PostArticlesError,
    PostArticlesVariables
  >(
    (variables: PostArticlesVariables) =>
      fetchPostArticles({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetArticlesByIdPathParams = {
  id: string;
};

export type GetArticlesByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.NotFoundErrorRef;
}>;

export type GetArticlesByIdVariables = {
  pathParams: GetArticlesByIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetArticlesById = (
  variables: GetArticlesByIdVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    Schemas.ArticleResponse,
    GetArticlesByIdError,
    undefined,
    {},
    {},
    GetArticlesByIdPathParams
  >({ url: "/api/v1/articles/{id}", method: "get", ...variables, signal });

export const useGetArticlesById = <TData = Schemas.ArticleResponse>(
  variables: GetArticlesByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ArticleResponse,
      GetArticlesByIdError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.ArticleResponse,
    GetArticlesByIdError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/articles/{id}",
      operationId: "getArticlesById",
      variables,
    }),
    ({ signal }) =>
      fetchGetArticlesById({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PutArticlesByIdPathParams = {
  id: string;
};

export type PutArticlesByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationErrorResponseRef;
    }
  | {
      status: 401;
      payload: Schemas.AuthRequiredErrorResponse;
    }
  | {
      status: 404;
      payload: Schemas.NotFoundErrorRef;
    }
>;

export type PutArticlesByIdVariables = {
  body: Schemas.EditArticleRequest;
  pathParams: PutArticlesByIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchPutArticlesById = (
  variables: PutArticlesByIdVariables,
  signal?: AbortSignal
) =>
  apiFetch<
    undefined,
    PutArticlesByIdError,
    Schemas.EditArticleRequest,
    {},
    {},
    PutArticlesByIdPathParams
  >({ url: "/api/v1/articles/{id}", method: "put", ...variables, signal });

export const usePutArticlesById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PutArticlesByIdError,
      PutArticlesByIdVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    PutArticlesByIdError,
    PutArticlesByIdVariables
  >(
    (variables: PutArticlesByIdVariables) =>
      fetchPutArticlesById({ ...fetcherOptions, ...variables }),
    options
  );
};

export type QueryOperation =
  | {
      path: "/api/v1/static";
      operationId: "getStatic";
      variables: GetStaticVariables;
    }
  | {
      path: "/api/v1/me";
      operationId: "getMe";
      variables: GetMeVariables;
    }
  | {
      path: "/api/v1/logout";
      operationId: "getLogout";
      variables: GetLogoutVariables;
    }
  | {
      path: "/api/v1/categories";
      operationId: "getCategories";
      variables: GetCategoriesVariables;
    }
  | {
      path: "/api/v1/notes";
      operationId: "getNotes";
      variables: GetNotesVariables;
    }
  | {
      path: "/api/v1/suggestions";
      operationId: "getSuggestions";
      variables: GetSuggestionsVariables;
    }
  | {
      path: "/api/v1/links-example";
      operationId: "getLinksExample";
      variables: GetLinksExampleVariables;
    }
  | {
      path: "/api/v1/notes/{id}/attachments";
      operationId: "getNotesByIdAttachments";
      variables: GetNotesByIdAttachmentsVariables;
    }
  | {
      path: "/api/v1/suggestion/{id}/links";
      operationId: "getSuggestionByIdLinks";
      variables: GetSuggestionByIdLinksVariables;
    }
  | {
      path: "/api/v1/sync";
      operationId: "getSync";
      variables: GetSyncVariables;
    }
  | {
      path: "/api/v1/articles";
      operationId: "getArticles";
      variables: GetArticlesVariables;
    }
  | {
      path: "/api/v1/articles/{id}";
      operationId: "getArticlesById";
      variables: GetArticlesByIdVariables;
    };
